---
title: データサイエンス100本ノック（構造化データ加工編） - Ruby (RedAmber) - 問題のみ
author: 鈴木 弘一 (@heronshoes)
format:
  pdf:
    toc: true
    toc-title: Contents
    number-sections: true
    colorlinks: true
lang: ja
pdf-engine: lualatex
documentclass: ltjsarticle
highlight-style: github
jupyter: ruby
---

## はじめに

このリポジトリは、一般社団法人データサイエンティスト協会が作成している「[データサイエンス100本ノック（構造化データ加工編）](https://github.com/The-Japan-DataScientist-Society/100knocks-preprocess)」の設問を抜き出して利用させて頂いた上で、Rubyで動くRedAmberの解答を作成したものです。上記原著のライセンスはMITライセンスであり、当リポジトリもMITライセンスに従います。

オリジナル([データサイエンス100本ノック（構造化データ加工編）](https://github.com/The-Japan-DataScientist-Society/100knocks-preprocess))に存在するデータ：
- `doc/data`以下のサンプルデータ
- このファイルの、設問タイトル及び設問の内容
オリジナルのライセンスは、MITライセンスです。

ここではRedAmberの設問と解答しか対応していませんが、代わりに次のような特徴があります。

* Apache Arrow を利用した RedAmber が動く Notebook 環境となっています
* 開発コンテナを利用しているため、高速かつ容易に環境の構築ができます
* Quarto を利用して、Jupyter Notebook のソースを qmd フォーマットで管理しています
* Quarto を利用して、pdf 形式で Notebookを出版できます

解答は、可能な限り元の設問に従っていますが、RedAmberの特性上、'全て表示せよ'という指示の問題でも該当するデータフレームを表すオブジェクトが得られていれば、画面上に全て表示されなくても可としています。なお、`ENV['RED_AMBER_OUTPUT_MODE'] = 'plain'`などとして環境変数'RED_AMBER_OUTPUT_MODE'を指定すると、データフレームの表示形式を変えることができます。

* 'table' : テーブルで表示する（既定値）
* 'plain' : 文字列のテーブルで表示する
* 'minimum' : 最小限の表示
* 'tdr' : 行・列を転置した `glimpse` 相当のモードで表示する

なお、データに含まれる名前、住所等はダミーデータであり、実在するものではありません。

## 使用方法

* 初めに以下のセルを実行してください
* 必要なライブラリとデータの読み込みを行います

```{ruby}
#| tags: [setting]
require 'red_amber.rb'
include RedAmber

ENV['RED_AMBER_OUTPUT_MODE'] = 'Table' # 'Table', 'TDR', 'TDRA', 'Plain' or 'Minimum'

data_source_path = '../data'

df_customer = DataFrame.load "#{data_source_path}/customer.csv"
df_category = DataFrame.load "#{data_source_path}/category.csv"
df_product  = DataFrame.load "#{data_source_path}/product.csv"
df_receipt  = DataFrame.load "#{data_source_path}/receipt.csv"
df_store    = DataFrame.load "#{data_source_path}/store.csv"
df_geocode  = DataFrame.load "#{data_source_path}/geocode.csv"

{RedAmber: VERSION, Arrow: Arrow::VERSION, Ruby: RUBY_VERSION}
```

## 演習問題

### RA-001. 全項目を指定行数抽出する

レシート明細データ（df_receipt）から全項目の先頭10件を表示し、どのようなデータを保有しているか目視で確認せよ。

```{ruby}
#
```

### RA-002. 特定の列を抽出する

レシート明細データ（df_receipt）から売上年月日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、10件表示せよ。

```{ruby}
#
```

### RA-003. 指定列の列名を変更する

レシート明細データ（df_receipt）から売上年月日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、10件表示せよ。ただし、sales_ymdをsales_dateに項目名を変更して抽出すること。

```{ruby}
#
```

### RA-004. 指定条件に合致する行を抽出する (==, >, <)

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が "CS018205000001"

```{ruby}
#
```

### RA-005. 複数条件に合致する行を抽出する (1)

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が　"CS018205000001"
- 売上金額（amount）が　1,000以上

```{ruby}
#
```

### RA-007. 複数条件に合致する行を抽出する (3)

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が "CS018205000001"
- 売上金額（amount）が 1,000以上2,000以下

```{ruby}
#
```

### RA-008. 特定条件に合致しない行を抽出する (!=)

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が "CS018205000001"
- 商品コード（product_cd）が "P071401019"以外

```{ruby}
#
```

### RA-009. ド・モルガンの法則で書き換える

以下の処理において、出力結果を変えずに | を & に書き換えよ。

> `df_store.filter { !((prefecture_cd == 13) | (floor_area > 900)) }`

```{ruby}
#
```

### RA-010. データの前方一致で条件指定する

店舗データ（df_store）から、店舗コード（store_cd）が"S14"で始まるものだけ全項目抽出し、10件表示せよ。

```{ruby}
#
```

### RA-011. データの後方一致で条件指定する

顧客データ（df_customer）から顧客ID（customer_id）の末尾が1のものだけ全項目抽出し、10件表示せよ。

```{ruby}
#
```

### RA-012. データの部分一致で条件指定する

店舗データ（df_store）から、住所 (address) に"横浜市"が含まれるものだけ全項目表示せよ。

```{ruby}
#
```

### RA-013. 正規表現の前方一致で条件指定する

顧客データ（df_customer）から、ステータスコード（status_cd）の先頭がアルファベットのA〜Fで始まるデータを全項目抽出し、10件表示せよ。

```{ruby}
#
```

### RA-014. 正規表現の後方一致で条件指定する

顧客データ（df_customer）から、ステータスコード（status_cd）の末尾が数字の1〜9で終わるデータを全項目抽出し、10件表示せよ。

```{ruby}
#
```

### RA-015. 正規表現の部分一致で条件指定する

顧客データ（df_customer）から、ステータスコード（status_cd）の先頭がアルファベットのA〜Fで始まり、末尾が数字の1〜9で終わるデータを全項目抽出し、10件表示せよ。

```{ruby}
#
```

### RA-016. 特定のデータ書式で条件指定する

店舗データ（df_store）から、電話番号（tel_no）が3桁-3桁-4桁のデータを全項目表示せよ。

```{ruby}
#
```

### RA-017. データを昇順に並べる

顧客データ（df_customer）を生年月日（birth_day）で高齢順にソートし、先頭から全項目を10件表示せよ。

```{ruby}
#
```

### RA-018. データを降順に並べる

顧客データ（df_customer）を生年月日（birth_day）で若い順にソートし、先頭から全項目を10件表示せよ。

```{ruby}
#
```

### RA-019. 順位付けする（同一順位あり）

レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合は同一順位を付与するものとする。

```{ruby}
#
```

### RA-020. 順位付けする（同一順位なし）

レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合でも別順位を付与すること。

```{ruby}
#
```

### RA-021. データの件数をカウントする

レシート明細データ（df_receipt）に対し、件数をカウントせよ。

```{ruby}
#
```

### RA-022. データのユニーク件数をカウントする

レシート明細データ（df_receipt）の顧客ID（customer_id）に対し、ユニーク件数をカウントせよ。

```{ruby}
#
```

### RA-023. 対象データの合計値を算出する

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）と売上数量（quantity）を合計せよ。

対象データを見ておきます。

```{ruby}
#
```

Groupクラスを使う方法：

```{ruby}
#
```

### RA-024. 対象データの最大値を求める

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も新しい売上年月日（sales_ymd）を求め、10件表示せよ。

```{ruby}
#
```

### RA-025. 対象データの最小値を求める

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も古い売上年月日（sales_ymd）を求め、10件表示せよ。

```{ruby}
#
```

### RA-026. 集計結果に対する条件指定で絞り込む

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も新しい売上年月日（sales_ymd）と古い売上年月日を求め、両者が異なるデータを10件表示せよ。

```{ruby}
#
```

### RA-027. 対象データの平均値を求める

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の平均を計算し、降順でTOP5を表示せよ。

```{ruby}
#
```

### RA-028. 対象データの中央値を求める

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の中央値を計算し、降順でTOP5を表示せよ。

```{ruby}
#
```

### RA-029. 対象データの最頻値を求める

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに商品コード（product_cd）の最頻値を求め、10件表示させよ。

```{ruby}
#
```

### RA-030. 対象データの分散を求める
レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の分散を計算し、降順で5件表示せよ。

```{ruby}
#
```

### RA-031. 対象データの標準偏差を求める

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の標準偏差を計算し、降順で5件表示せよ。

```{ruby}
#
```

### RA-032. データのパーセンタイル値を求める

レシート明細データ（df_receipt）の売上金額（amount）について、25％刻みでパーセンタイル値を求めよ。

```{ruby}
#
```

### RA-033. 統計量に対する条件指定で絞り込む

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の平均を計算し、330以上のものを抽出せよ。

```{ruby}
#
```

### RA-034. 検索結果から集計する

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに売上金額（amount）を合計して全顧客の平均を求めよ。ただし、顧客IDが"Z"から始まるものは非会員を表すため、除外して計算すること。

```{ruby}
#
```

### RA-035. 検索結果を条件指定に使った副問い合わせを行う

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに売上金額（amount）を合計して全顧客の平均を求め、平均以上に買い物をしている顧客を抽出し、10件表示せよ。ただし、顧客IDが"Z"から始まるものは非会員を表すため、除外して計算すること。

```{ruby}
#
```

### RA-036. トランザクションとマスタを内部結合する

レシート明細データ（df_receipt）と店舗データ（df_store）を内部結合し、レシート明細データの全項目と店舗データの店舗名（store_name）を10件表示せよ。

```{ruby}
#
```

### RA-037. マスタ同士を内部結合する

商品データ（df_product）とカテゴリデータ（df_category）を内部結合し、商品データの全項目とカテゴリデータのカテゴリ小区分名（category_small_name）を10件表示せよ。

```{ruby}
#
```

### RA-038. 左外部結合でデータを残す

顧客データ（df_customer）とレシート明細データ（df_receipt）から、顧客ごとの売上金額合計を求め、10件表示せよ。ただし、売上実績がない顧客については売上金額を0として表示させること。また、顧客は性別コード（gender_cd）が女性（1）であるものを対象とし、非会員（顧客IDが"Z"から始まるもの）は除外すること。

```{ruby}
#
```

### RA-039. 完全外部結合で全てのレコードを残す

レシート明細データ（df_receipt）から、売上日数の多い顧客の上位20件を抽出したデータと、売上金額合計の多い顧客の上位20件を抽出したデータをそれぞれ作成し、さらにその2つを完全外部結合せよ。ただし、非会員（顧客IDが"Z"から始まるもの）は除外すること。

会員のデータを取り出して、amountが0やnilのレコードがないかどうか確かめ、customer_idでグループ化しておく。

```{ruby}
#
```

### RA-040. クロス結合で全てのレコードの組み合わせを作成する

全ての店舗と全ての商品を組み合わせたデータを作成したい。店舗データ（df_store）と商品データ（df_product）を直積し、件数を計算せよ。

```{ruby}
#
```

### RA-041. n件前のデータを結合する

レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、前回売上があった日からの売上金額増減を計算せよ。そして結果を10件表示せよ。

```{ruby}
#
```

注）　シフトした列を直接加えることで、「前回売上年月日」の列は生成していない。

### RA-042. 過去n件のデータを結合する

レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、各日付のデータに対し、前回、前々回、3回前に売上があった日のデータを結合せよ。そして結果を10件表示せよ。

```{ruby}
#
```

### RA-043. 縦持ちデータを横持ちデータに変換する

レシート明細データ（df_receipt）と顧客データ（df_customer）を結合し、性別コード（gender_cd）と年代（ageから計算）ごとに売上金額（amount）を合計した売上サマリデータを作成せよ。性別コードは0が男性、1が女性、9が不明を表すものとする。

ただし、項目構成は年代、女性の売上金額、男性の売上金額、性別不明の売上金額の4項目とすること（縦に年代、横に性別のクロス集計）。また、年代は10歳ごとの階級とすること。

```{ruby}
#
```

### RA-044. 横持ちデータを縦持ちデータに変換する

043で作成した売上サマリデータ（df_sales_summary）は性別の売上を横持ちさせたものであった。このデータから性別を縦持ちさせ、年代、性別コード、売上金額の3項目に変換せよ。ただし、性別コードは男性を"00"、女性を"01"、不明を"99"とする。

```{ruby}
#
```

### RA-045. 日付型データを文字列データに変換する

顧客データ（df_customer）の生年月日（birth_day）は日付型でデータを保有している。これをYYYYMMDD形式の文字列に変換し、顧客ID（customer_id）とともに10件表示せよ。

```{ruby}
#
```

### RA-046. 文字列データを日付型データに変換する

顧客データ（df_customer）の申し込み日（application_date）はYYYYMMDD形式の文字列型でデータを保有している。これを日付型に変換し、顧客ID（customer_id）とともに10件表示せよ。

```{ruby}
#
```

### RA-047. 数値データを日付型データに変換する

レシート明細データ（df_receipt）の売上日（sales_ymd）はYYYYMMDD形式の数値型でデータを保有している。これを日付型に変換し、レシート番号（receipt_no）、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。

```{ruby}
#
```

### RA-048. エポック秒（UNIX時間）を日付型データに変換する

レシート明細データ（df_receipt）の売上エポック秒（sales_epoch）は数値型のUNIX秒でデータを保有している。これを日付型に変換し、レシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。

```{ruby}
#
```

### RA-049. 日付データから特定の年だけ取り出す

レシート明細データ（df_receipt）の売上エポック秒（sales_epoch）を日付型に変換し、「年」だけ取り出してレシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。

```{ruby}
#
```

### RA-050. 日付データから特定の月だけ取り出す

レシート明細データ（df_receipt）の売上エポック秒（sales_epoch）を日付型に変換し、「月」だけ取り出してレシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。なお、「月」は0埋め2桁で取り出すこと。

```{ruby}
#
```

### RA-051. 日付データから特定の日だけ取り出す

レシート明細データ（df_receipt）の売上エポック秒を日付型に変換し、「日」だけ取り出してレシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。なお、「日」は0埋め2桁で取り出すこと。

```{ruby}
#
```

### RA-052. 数値データを二値（０と１）データに変換する

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計の上、売上金額合計に対して2,000円以下を0、2,000円より大きい金額を1に二値化し、顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#
```

### RA-053. 文字データを二値（０と１）データに変換する

顧客データ（df_customer）の郵便番号（postal_cd）に対し、東京（先頭3桁が100〜209のもの）を1、それ以外のものを0に二値化せよ。さらにレシート明細データ（df_receipt）と結合し、全期間において売上実績のある顧客数を、作成した二値ごとにカウントせよ。

```{ruby}
#
```

### RA-054. テキストラベルからカテゴリーデータを作成する

顧客データ（df_customer）の住所（address）は、埼玉県、千葉県、東京都、神奈川県のいずれかとなっている。都道府県毎にコード値を作成し、顧客ID、住所とともに10件表示せよ。値は埼玉県を11、千葉県を12、東京都を13、神奈川県を14とすること。

```{ruby}
#
```

### RA-055. 数値からカテゴリーデータを作成する

レシート明細（df_receipt）データの売上金額（amount）を顧客ID（customer_id）ごとに合計し、その合計金額の四分位点を求めよ。その上で、顧客ごとの売上金額合計に対して以下の基準でカテゴリ値を作成し、顧客ID、売上金額合計とともに10件表示せよ。カテゴリ値は順に1〜4とする。

- 最小値以上第1四分位未満    ・・・ 1を付与
- 第1四分位以上第2四分位未満 ・・・ 2を付与
- 第2四分位以上第3四分位未満 ・・・ 3を付与
- 第3四分位以上            ・・・ 4を付与

```{ruby}
#
```

### RA-056. 件数の少ないカテゴリーを適切なカテゴリーに寄せる

顧客データ（df_customer）の年齢（age）をもとに10歳刻みで年代を算出し、顧客ID（customer_id）、生年月日（birth_day）とともに10件表示せよ。ただし、60歳以上は全て60歳代とすること。年代を表すカテゴリ名は任意とする。

```{ruby}
#
```

### RA-057. カテゴリー同士を組み合わせた新たなカテゴリーを作成する

056の抽出結果と性別コード（gender_cd）により、新たに性別×年代の組み合わせを表すカテゴリデータを作成し、10件表示せよ。組み合わせを表すカテゴリの値は任意とする。

```{ruby}
#
```

### RA-058. ダミー変数（０と１）に変換する（カテゴリ型→ダミー変数）

顧客データ（df_customer）の性別コード（gender_cd）をダミー変数化し、顧客ID（customer_id）とともに10件表示せよ。

```{ruby}
#
```

### RA-059. 平均0、分散１に変換する

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を平均0、標準偏差1に標準化して顧客ID、売上金額合計とともに10件表示せよ。標準化に使用する標準偏差は、分散の平方根、もしくは不偏分散の平方根のどちらでも良いものとする。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#
```

### RA-060. 最小値0、最大値1に変換する

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を最小値0、最大値1に正規化して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#
```

### RA-061. 数値データを対数変換する（常用対数）

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を常用対数化（底10）して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#
```

### RA-062. 数値データを対数変換する（自然対数）

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を自然対数化（底e）して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#
```

### RA-063. 数値を引き算する

商品データ（df_product）の単価（unit_price）と原価（unit_cost）から各商品の利益額を算出し、結果を10件表示せよ。

```{ruby}
#
```

### RA-064. 数値を割り算する

商品データ（df_product）の単価（unit_price）と原価（unit_cost）から、各商品の利益率の全体平均を算出せよ。ただし、単価と原価には欠損が生じていることに注意せよ。

```{ruby}
#
```

### RA-065. 除算結果に対して有効数字未満を切り捨てる

商品データ（df_product）の各商品について、利益率が30%となる新たな単価を求めよ。ただし、1円未満は切り捨てること。そして結果を10件表示させ、利益率がおよそ30％付近であることを確認せよ。ただし、単価（unit_price）と原価（unit_cost）には欠損が生じていることに注意せよ。

```{ruby}
#
```

### RA-066. 除算結果に対して有効数字未満を四捨五入する

商品データ（df_product）の各商品について、利益率が30%となる新たな単価を求めよ。今回は、1円未満を丸めること（四捨五入または偶数への丸めで良い）。そして結果を10件表示させ、利益率がおよそ30％付近であることを確認せよ。ただし、単価（unit_price）と原価（unit_cost）には欠損が生じていることに注意せよ。

```{ruby}
#
```

### RA-067. 除算結果に対して有効数字未満を切り上げる

商品データ（df_product）の各商品について、利益率が30%となる新たな単価を求めよ。今回は、1円未満を切り上げること。そして結果を10件表示させ、利益率がおよそ30％付近であることを確認せよ。ただし、単価（unit_price）と原価（unit_cost）には欠損が生じていることに注意せよ。

```{ruby}
#
```

### RA-068. 除算結果に対して有効桁数未満を切り捨てる

商品データ（df_product）の各商品について、消費税率10％の税込み金額を求めよ。1円未満の端数は切り捨てとし、結果を10件表示せよ。ただし、単価（unit_price）には欠損が生じていることに注意せよ。

```{ruby}
#
```

### RA-069. 集計結果から割合を計算する

レシート明細データ（df_receipt）と商品データ（df_product）を結合し、顧客毎に全商品の売上金額合計と、カテゴリ大区分コード（category_major_cd）が"07"（瓶詰缶詰）の売上金額合計を計算の上、両者の比率を求めよ。抽出対象はカテゴリ大区分コード"07"（瓶詰缶詰）の売上実績がある顧客のみとし、結果を10件表示せよ。

```{ruby}
#
```

### RA-070. 2つの日付から経過日数を計算する

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、顧客データ（df_customer）の会員申込日（application_date）からの経過日数を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。

```{ruby}
#
```


### RA-071. 2つの日付から経過月数を計算する

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、顧客データ（df_customer）の会員申込日（application_date）からの経過月数を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。1ヶ月未満は切り捨てること。

```{ruby}
#
```


### RA-072. 2つの日付から経過年数を計算する

レシート明細データ（df_receipt）の売上日（df_customer）に対し、顧客データ（df_customer）の会員申込日（application_date）からの経過年数を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。1年未満は切り捨てること。

```{ruby}
#
```


### RA-073. 2つの日付から経過時間をエポック秒で計算する

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、顧客データ（df_customer）の会員申込日（application_date）からのエポック秒による経過時間を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（なお、sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。なお、時間情報は保有していないため各日付は0時0分0秒を表すものとする。

```{ruby}
#
```


### RA-074. 月曜日からの経過日数を計算する

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、当該週の月曜日からの経過日数を計算し、売上日、直前の月曜日付とともに10件表示せよ（sales_ymdは数値でデータを保持している点に注意）。

```{ruby}
#
```


### RA-075. ランダムサンプリングを行う（単純無作為抽出）

顧客データ（df_customer）からランダムに1%のデータを抽出し、先頭から10件表示せよ。

```{ruby}
#
```


### RA-076. カテゴリの割合に応じたサンプリングを行う（層化抽出）

顧客データ（df_customer）から性別コード（gender_cd）の割合に基づきランダムに10%のデータを層化抽出し、性別コードごとに件数を集計せよ。

```{ruby}
#
```


### RA-077. 統計的に外れ値を除外する（3σ外の除外）

レシート明細データ（df_receipt）の売上金額を顧客単位に合計し、合計した売上金額の外れ値を抽出せよ。なお、外れ値は売上金額合計を対数化したうえで平均と標準偏差を計算し、その平均から3σを超えて離れたものとする（自然対数と常用対数のどちらでも可）。結果は10件表示せよ。

```{ruby}
#
```


### RA-078. 統計的に外れ値を除外する（IQR1.5倍）

レシート明細データ（df_receipt）の売上金額（amount）を顧客単位に合計し、合計した売上金額の外れ値を抽出せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。なお、ここでは外れ値を第1四分位と第3四分位の差であるIQRを用いて、「第1四分位数-1.5×IQR」を下回るもの、または「第3四分位数+1.5×IQR」を超えるものとする。結果は10件表示せよ。

```{ruby}
#
```


### RA-079. 欠損値がある列を確認する

商品データ（df_product）の各項目に対し、欠損数を確認せよ。

```{ruby}
#
```


### RA-080. 欠損値があるレコードを削除する

商品データ（df_product）のいずれかの項目に欠損が発生しているレコードを全て削除した新たな商品データを作成せよ。なお、削除前後の件数を表示させ、079で確認した件数だけ減少していることも確認すること。

```{ruby}
#
```


### RA-081. 平均値を用いて欠損値を補完する

単価（unit_price）と原価（unit_cost）の欠損値について、それぞれの平均値で補完した新たな商品データを作成せよ。なお、平均値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。

```{ruby}
#
```


### RA-082. 中央値を用いて欠損値を補完する

単価（unit_price）と原価（unit_cost）の欠損値について、それぞれの中央値で補完した新たな商品データを作成せよ。なお、中央値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。

```{ruby}
#
```


### RA-083. カテゴリ毎に算出した中央値で欠損値を補完する

単価（unit_price）と原価（unit_cost）の欠損値について、各商品のカテゴリ小区分コード（category_small_cd）ごとに算出した中央値で補完した新たな商品データを作成せよ。なお、中央値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。

```{ruby}
#
```


### RA-084. 分母が欠損値や0の場合でも除算結果データを作成する

顧客データ（df_customer）の全顧客に対して全期間の売上金額に占める2019年売上金額の割合を計算し、新たなデータを作成せよ。ただし、売上実績がない場合は0として扱うこと。そして計算した割合が0超のものを抽出し、結果を10件表示せよ。また、作成したデータに欠損が存在しないことを確認せよ。

```{ruby}
#
```


改善の余地ありかもしれません。

### RA-085. 郵便番号からジオコードに変換する

顧客データ（df_customer）の全顧客に対し、郵便番号（postal_cd）を用いてジオコードデータ（df_geocode）を紐付け、新たな顧客データを作成せよ。ただし、1つの郵便番号（postal_cd）に複数の経度（longitude）、緯度（latitude）情報が紐づく場合は、経度（longitude）、緯度（latitude）の平均値を算出して使用すること。また、作成結果を確認するために結果を10件表示せよ。

```{ruby}
#
```


### RA-086. 軽度緯度から距離を計算する

085で作成した緯度経度つき顧客データに対し、会員申込店舗コード（application_store_cd）をキーに店舗データ（df_store）と結合せよ。そして申込み店舗の緯度（latitude）・経度情報（longitude)と顧客住所（address）の緯度・経度を用いて申込み店舗と顧客住所の距離（単位：km）を求め、顧客ID（customer_id）、顧客住所（address）、店舗住所（address）とともに表示せよ。計算式は以下の簡易式で良いものとするが、その他精度の高い方式を利用したライブラリを利用してもかまわない。結果は10件表示せよ。

$$
\mbox{緯度（ラジアン）}：\phi
$$
$$
\mbox{経度（ラジアン）}：\lambda
$$
$$
\mbox{距離}L = 6371 * \arccos(\sin \phi_1 * \sin \phi_2
+ \cos \phi_1 * \cos \phi_2 * \cos(\lambda_1 − \lambda_2))
$$

```{ruby}
#
```


### RA-087. 主キー以外の項目を利用した名寄せを行う

顧客データ（df_customer）では、異なる店舗での申込みなどにより同一顧客が複数登録されている。名前（customer_name）と郵便番号（postal_cd）が同じ顧客は同一顧客とみなして1顧客1レコードとなるように名寄せした名寄顧客データを作成し、顧客データの件数、名寄顧客データの件数、重複数を算出せよ。ただし、同一顧客に対しては売上金額合計が最も高いものを残し、売上金額合計が同一もしくは売上実績がない顧客については顧客ID（customer_id）の番号が小さいものを残すこととする。

```{ruby}
#
```


### RA-088. 名寄変換データを作成する

087で作成したデータを元に、顧客データに統合名寄IDを付与したデータを作成せよ。ただし、統合名寄IDは以下の仕様で付与するものとする。

- 重複していない顧客：顧客ID（customer_id）を設定
- 重複している顧客：前設問で抽出したレコードの顧客IDを設定

顧客IDのユニーク件数と、統合名寄IDのユニーク件数の差も確認すること。

```{ruby}
#
```


### RA-089. ホールドアウト法によるデータの分割を行う

売上実績がある顧客を、予測モデル構築のため学習用データとテスト用データに分割したい。それぞれ8:2の割合でランダムにデータを分割せよ。

```{ruby}
#
```


### RA-090. 時系列データを分割する

レシート明細データ（df_receipt）は2017年1月1日〜2019年10月31日までのデータを有している。売上金額（amount）を月次で集計し、学習用に12ヶ月、テスト用に6ヶ月の時系列モデル構築用データを3セット作成せよ。

```{ruby}
#
```


### RA-091. アンダーサンプリングにより不均衡データを調整する

顧客データ（df_customer）の各顧客に対し、売上実績がある顧客数と売上実績がない顧客数が1:1となるようにアンダーサンプリングで抽出せよ。

```{ruby}
#
```


### RA-092. 第三正規形に正規化する

顧客データ（df_customer）の性別について、第三正規形へと正規化せよ。

```{ruby}
#
```


### RA-093. 第三正規形から非正規化する

商品データ（df_product）では各カテゴリのコード値だけを保有し、カテゴリ名は保有していない。カテゴリデータ（df_category）と組み合わせて非正規化し、カテゴリ名を保有した新たな商品データを作成せよ。

```{ruby}
#
```


### RA-094. ヘッダ有無と文字エンコーディングを指定し、CSVファイルを作成する(1)

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|有り|UTF-8|
>
> ファイル出力先のパスは以下のようにすること
>
> |出力先|
> |:--:|
> |./work|

```{ruby}
#
```


### RA-095. ヘッダ有無と文字エンコーディングを指定し、CSVファイルを作成する(2)

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|有り|CP932|
>
> ファイル出力先のパスは以下のようにすること。
>
> |出力先|
> |:--:|
> |./work|

```{ruby}
#
```

### RA-096. ヘッダ有無と文字エンコーディングを指定し、CSVファイルを作成する(3)

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|無し|UTF-8|
>
> ファイル出力先のパスは以下のようにすること。
>
> |出力先|
> |:--:|
> |./work|

```{ruby}
#
```

### RA-097. ヘッダ有無と文字エンコーディングを指定し、CSVファイルを読み込む(1)

094で作成した以下形式のファイルを読み込み、データを3件を表示させて正しく取り込まれていることを確認せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|有り|UTF-8|

```{ruby}
#
```


### RA-098. ヘッダ有無と文字エンコーディングを指定し、CSVファイルを読み込む(2)

096で作成した以下形式のファイルを読み込み、データを3件を表示させて正しく取り込まれていることを確認せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|ヘッダ無し|UTF-8|

```{ruby}
#
```


### RA-099. ヘッダ有無と文字エンコーディングを指定し、TSVファイルを作成する

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |TSV（タブ区切り）|有り|UTF-8|
>
> ファイル出力先のパスは以下のようにすること
>
> |出力先|
> |:--:|
> |./work|

```{ruby}
#
```


### RA-100. ヘッダ有無と文字エンコーディングを指定し、TSVファイルを読み込む

099で作成した以下形式のファイルを読み込み、データを3件を表示させて正しく取り込まれていることを確認せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |TSV（タブ区切り）|有り|UTF-8|

```{ruby}
#
```


これで100本終わりです。おつかれさまでした！

