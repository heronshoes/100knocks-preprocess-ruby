---
title: データサイエンス100本ノック（構造化データ加工編） - Ruby (RedAmber)
author: 鈴木 弘一 (@heronshoes)
format:
  pdf:
    toc: true
    toc-title: Contents
    number-sections: true
    colorlinks: true
pdf-engine: lualatex
documentclass: book
highlight-style: github
jupyter: ruby
---



## はじめに

このリポジトリは、一般社団法人データサイエンティスト協会が作成している「[データサイエンス100本ノック（構造化データ加工編）](https://github.com/The-Japan-DataScientist-Society/100knocks-preprocess)」の設問を利用させて頂き、Rubyで動くRedAmberの設問と解答に改変したものです。上記原著のライセンスはMITライセンスであり、当リポジトリもMITライセンスに従います。

現在のところ、RedAmberの設問と解答しか用意されていませんが、代わりに次のような特徴があります。

* Apache Arrow を利用した RedAmber が動く Notebook 環境です
* 開発コンテナを利用しているため、特にVS Codeのユーザーにとっては容易に環境の構築ができます
* Quarto を利用して、Jupyter Notebook のソースを qmd フォーマットで管理しています
* Quarto を利用して、pdf 形式で Notebookを出版できます

解答は、可能な限り設問に従っていますが、RedAmberの特性上、'全て表示せよ'という指示の問題でも該当するデータフレームを表すオブジェクトが得られていれば、画面上に全て表示されなくても可としています。なお、`ENV['RED_AMBER_OUTPUT_MODE'] = 'plain'`などとして環境変数'RED_AMBER_OUTPUT_MODE'を指定すると、データフレームの表示形式を変えることができます。

* 'table' : テーブルで表示する（既定値）
* 'plain' : 文字列のテーブルで表示する
* 'minimum' : 最小限の表示
* 'tdr' : 行・列を転置した `glimpse` 相当のモードで表示する

## 使用方法

* 初めに以下のセルを実行してください
* 必要なライブラリとデータの読み込みを行います
* 名前、住所等はダミーデータであり、実在するものではありません

```{ruby}
#| tags: ["setting"]
require 'red_amber.rb'
include RedAmber

ENV['RED_AMBER_OUTPUT_MODE'] = 'Table' # 'Table', 'TDR', 'TDRA', 'Plain' or 'Minimum'

data_source_path = './data'

df_customer = DataFrame.load "#{data_source_path}/customer.csv"
df_category = DataFrame.load "#{data_source_path}/category.csv"
df_product  = DataFrame.load "#{data_source_path}/product.csv"
df_receipt  = DataFrame.load "#{data_source_path}/receipt.csv"
df_store    = DataFrame.load "#{data_source_path}/store.csv"
df_geocode  = DataFrame.load "#{data_source_path}/geocode.csv"

{RedAmber: VERSION, Arrow: Arrow::VERSION, Ruby: RUBY_VERSION}
```

## 演習問題

### RA-001

レシート明細データ（df_receipt）から全項目の先頭10件を表示し、どのようなデータを保有しているか目視で確認せよ。

```{ruby}
#| collapsed: true
#| jupyter: {outputs_hidden: true}
#| scrolled: true
#| tags: ["answer"]
df_receipt.head(10)
```


### RA-002

レシート明細データ（df_receipt）から売上年月日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(%i[sales_ymd customer_id product_cd amount])
  .head(10)
```


### RA-003

レシート明細データ（df_receipt）から売上年月日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、10件表示せよ。ただし、sales_ymdをsales_dateに項目名を変更して抽出すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick { %i[sales_ymd customer_id product_cd amount] }
  .rename(sales_ymd: :sales_date)
  .head(10)
```


### RA-004

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が"CS018205000001"

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick { %i[sales_ymd customer_id product_cd amount] }
  .filter { customer_id == 'CS018205000001' }
```


### RA-005

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が"CS018205000001"
- 売上金額（amount）が1,000以上

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick { %i[sales_ymd customer_id product_cd amount] }
  .filter { (customer_id == 'CS018205000001') & (amount >= 1000) }
```


### RA-006

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上数量（quantity）、売上金額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が"CS018205000001"
- 売上金額（amount）が1,000以上または売上数量（quantity）が5以上

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick { %i[sales_ymd customer_id product_cd quantity amount] }
  .filter do
    (customer_id == 'CS018205000001') & ((amount >= 1000) | (quantity >= 5))
  end
```


### RA-007

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が"CS018205000001"
- 売上金額（amount）が1,000以上2,000以下

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick { %i[sales_ymd customer_id product_cd amount] }
  .filter do
    (customer_id == 'CS018205000001') & ((amount >= 1000) & (amount <= 2000))
  end
```


### RA-008

レシート明細データ（df_receipt）から売上日（sales_ymd）、顧客ID（customer_id）、商品コード（product_cd）、売上金額（amount）の順に列を指定し、以下の全ての条件を満たすデータを抽出せよ。
- 顧客ID（customer_id）が"CS018205000001"
- 商品コード（product_cd）が"P071401019"以外

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick { %i[sales_ymd customer_id product_cd amount] }
  .filter do
    (customer_id == 'CS018205000001') & (product_cd != 'P071401019')
  end
```


### RA-009

以下の処理において、出力結果を変えずにORをANDに書き換えよ。

> `df_store.filter { !((prefecture_cd == 13) | (floor_area > 900)) }`

```{ruby}
#| tags: ["answer"]
df_store.filter { !((prefecture_cd == 13) | (floor_area > 900)) }
```


### RA-010

店舗データ（df_store）から、店舗コード（store_cd）が"S14"で始まるものだけ全項目抽出し、10件表示せよ。

```{ruby}
#| tags: ["answer"]
# Since RedAmber 0.5.0
df_store
  .filter { store_cd.start_with?('S14') }
  .head(10)
```

```{ruby}
#| tags: []
# 参考 RedAmber 0.4.2以前
df_store
  .slice { store_cd.map { _1.start_with?('S14') } }
  .head(10)
```

### RA-011

顧客データ（df_customer）から顧客ID（customer_id）の末尾が1のものだけ全項目抽出し、10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .filter { customer_id.end_with?('1') }
  .head(10)
```


### RA-012

店舗データ（df_store）から、住所 (address) に"横浜市"が含まれるものだけ全項目表示せよ。

```{ruby}
#| tags: ["answer"]
df_store.filter { address.match_substring?('横浜市') }
```


### RA-013

顧客データ（df_customer）から、ステータスコード（status_cd）の先頭がアルファベットのA〜Fで始まるデータを全項目抽出し、10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .filter { status_cd.match_substring?(/^[A-F]/) }
  .head(10)
```


### RA-014

顧客データ（df_customer）から、ステータスコード（status_cd）の末尾が数字の1〜9で終わるデータを全項目抽出し、10件表示せよ。

```{ruby}
#| tags: ["answer"]
# Since RedAmber 0.5.0
df_customer
  .filter { status_cd.match_substring?(/[1-9]$/) }
  .head(10)
```

```{ruby}
#| tags: []
# 参考 RedAmber 0.4.2以前
df_customer
  .filter do
    status_cd.map { _1[-1] }.is_in('1'..'9')
  end
  .head(10)
```


### RA-015

顧客データ（df_customer）から、ステータスコード（status_cd）の先頭がアルファベットのA〜Fで始まり、末尾が数字の1〜9で終わるデータを全項目抽出し、10件表示せよ。

```{ruby}
#| tags: ["answer"]
# Since RedAmber 0.5.0
df_customer
  .filter { status_cd.match_substring?(/^[A-F].+[1-9]$/) }
  .head(10)
```

```{ruby}
#| tags: []
# 参考 RedAmber 0.4.2以前
df_customer
  .filter do
    status_cd.map { _1[0] }.is_in('A'..'F') &
    status_cd.map { _1[-1] }.is_in('1'..'9')
  end
  .head(10)
```


### RA-016

店舗データ（df_store）から、電話番号（tel_no）が3桁-3桁-4桁のデータを全項目表示せよ。

```{ruby}
#| tags: []
# 参考のため電話番号の列を表示
df_store.tel_no
```

```{ruby}
#| tags: ["answer"]
df_store.filter { tel_no.match_substring?(/\d{3}-\d{3}-\d{4}/) }
```


### RA-017

顧客データ（df_customer）を生年月日（birth_day）で高齢順にソートし、先頭から全項目を10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .sort('birth_day')
  .head(10)
```


### RA-018

顧客データ（df_customer）を生年月日（birth_day）で若い順にソートし、先頭から全項目を10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .sort('-birth_day')
  .head(10)
```


### RA-019

レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合は同一順位を付与するものとする。

```{ruby}
#| tags: ["answer"]
# Since RedAmber 0.5.0
df_receipt
  .pick(:customer_id, :amount)
  .sort('-amount')
  .head(10)
  .assign(:amount_rank) { amount.rank(sort_order: 'ascending', tie: :min) }
```

```{ruby}
#| tags: []
# 参考 RedAmber 0.4.2以前
counts = df_receipt.amount.sort(:'-').tally.values
i = 1
counts.each_with_object([]) do |c, ary|
  ary.concat([i] * c)
  i += c
end => rank
df_receipt
  .pick(:customer_id, :amount)
  .sort('-amount')
  .assign(:amount_rank) { rank }
  .head(10)
```

### RA-020

レシート明細データ（df_receipt）に対し、1件あたりの売上金額（amount）が高い順にランクを付与し、先頭から10件表示せよ。項目は顧客ID（customer_id）、売上金額（amount）、付与したランクを表示させること。なお、売上金額（amount）が等しい場合でも別順位を付与すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(%i[customer_id amount])
  .sort('-amount')
  .head(10)
  .assign(:amount_rank) { amount.rank }
```


### RA-021

レシート明細データ（df_receipt）に対し、件数をカウントせよ。

```{ruby}
#| tags: ["answer"]
df_receipt.size
```

### RA-022

レシート明細データ（df_receipt）の顧客ID（customer_id）に対し、ユニーク件数をカウントせよ。

```{ruby}
#| tags: ["answer"]
df_receipt.customer_id.count_uniq
```

```{ruby}
#| tags: []
df_receipt.customer_id.unique.size
```

```{ruby}
#| tags: []
df_receipt.customer_id.to_a.uniq.size
```

ベンチマークによる比較。

```{ruby}
#| tags: []
require 'benchmark_driver'

Benchmark.driver do |x|
  x.prelude %{
    require 'red_amber'
    data_source_path = './data'

    df_receipt = RedAmber::DataFrame.load "#{data_source_path}/receipt.csv"
    vector = df_receipt.customer_id
    array = vector.to_a
  }
  x.report %{ vector.unique.size }
  x.report %{ vector.count_uniq }
  x.report %{ array.uniq.size }
end;nil
```

### RA-023

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）と売上数量（quantity）を合計せよ。

```{ruby}
#| tags: []
df_receipt.head
```

Groupクラスを使う方法

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:store_cd)
  .summarize(:sum_amount, :sum_quantity) { [sum(:amount), sum(:quantity)] }
```

SubFramesクラスを使う方法(遅いです)

```{ruby}
#| tags: []
df_receipt
  .pick(%i[store_cd amount quantity])
  .sub_group(:store_cd)
  .aggregate(:store_cd, :sum_amount, :sum_quantity) do
    [store_cd.one, amount.sum, quantity.sum]
  end
```

別のやり方

```{ruby}
#| tags: []
df = df_receipt.pick(%i[store_cd amount quantity])
filters = df.group(:store_cd).filters
filters.map do |filter|
  sub = df.slice(filter)
  [sub.store_cd.one, sub.amount.sum, sub.quantity.sum]
end.transpose => values
DataFrame.new(%i[store_cd sum_amount sum_quantity].zip(values))
```

### RA-024

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も新しい売上年月日（sales_ymd）を求め、10件表示せよ。

```{ruby}
#| tags: ["answer"]
SubFrames
  .by_dataframes(
    df_receipt
      .group(:customer_id)
      .take(10)
  ).aggregate do
    { customer_id: customer_id.one,
        sales_ymd: sales_ymd.max }
  end
```

### RA-025

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も古い売上年月日（sales_ymd）を求め、10件表示せよ。

```{ruby}
#| tags: ["answer"]
filters = df_receipt.group(:customer_id).filters.take(10)
SubFrames.by_filters(df_receipt, filters)
  .aggregate do
    { customer_id: customer_id.first,
        sales_ymd: sales_ymd.max }
  end
```

### RA-026

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに最も新しい売上年月日（sales_ymd）と古い売上年月日を求め、両者が異なるデータを10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:customer_id)
  .summarize(:max_sales_ymd, :min_sales_ymd) { [max(:sales_ymd), min(:sales_ymd)] }
  .slice { max_sales_ymd != min_sales_ymd }
  .head(10)
```

### RA-027

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の平均を計算し、降順でTOP5を表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:store_cd, :amount)
  .group(:store_cd) { mean(:amount) }
  .sort('-mean(amount)')
  .head(5)
```

### RA-028

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の中央値を計算し、降順でTOP5を表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:store_cd, :amount)
  .sub_group(:store_cd)
  .aggregate do
    {      store_cd: store_cd.first,
      median_amount: amount.median }
  end
  .sort('-median_amount')
  .head(5)
```

### RA-029

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに商品コード（product_cd）の最頻値を求め、10件表示させよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:store_cd, :product_cd, :amount)
  .sub_group(:store_cd)
  .aggregate do
    code, code_count = product_cd.tally.max { |a, b| a[1] <=> b[1] }
    {
      store_cd: store_cd.one,
      product_cd: code,
      product_cd_count: code_count
    }
  end
  .tap { p _1.size }
  .head(10)
```

解説) 

Arrowのgroupingでは、hash_mode()はないので最頻値を求めることはできない。代わりに、速度は遅いがSubFramesを使っている。

`Vector#mode`は数値型にしか使えない。
参考に、元になっているArrow C++のドキュメントを表示させると下記のようになる。なお、Arrow 12.0.0 (RedAmber 0.5.0) ではまだオプション(ModeOptions)が使えるようになっていない。

```{ruby}
puts ArrowFunction::arrow_doc(:mode)
```

代わりに`Vector#tally`を使い、得られたHashのvalueの最大値から最頻値を求めている。

```{ruby}
#| tags: []
df_receipt.product_cd.tally.max { |a, b| a[1] <=> b[1] }
```

### RA-030

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の分散を計算し、降順で5件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .sub_group(:store_cd)
  .aggregate do
    { store_cd: store_cd.first,
      var_amount: amount.var }
  end
  .sort('-var_amount')
  .head(5)
```


### RA-031

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の標準偏差を計算し、降順で5件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .sub_group(:store_cd)
  .aggregate do
    { store_cd: store_cd.first,
      sd_amount: amount.sd }
  end
  .sort('-sd_amount')
  .head(5)
```

RedAmberでは、数値Vectorに対するメソッドとして、`#sd`, `#var`は unbiasedつまり不偏標準偏差, 不偏分散、`#stddev`, `#variance`が標準偏差、分散である。

### RA-032

レシート明細データ（df_receipt）の売上金額（amount）について、25％刻みでパーセンタイル値を求めよ。

```{ruby}
#| tags: ["answer"]
df_receipt.amount.quantile(0.25)
```


### RA-033

レシート明細データ（df_receipt）に対し、店舗コード（store_cd）ごとに売上金額（amount）の平均を計算し、330以上のものを抽出せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:store_cd)
  .summarize(:amount) { mean(:amount) }
  .slice { amount > 330 }
```


### RA-034

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに売上金額（amount）を合計して全顧客の平均を求めよ。ただし、顧客IDが"Z"から始まるものは非会員を表すため、除外して計算すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:customer_id)
  .count
  .slice { customer_id.start_with?('Z') }
```


### RA-035

レシート明細データ（df_receipt）に対し、顧客ID（customer_id）ごとに売上金額（amount）を合計して全顧客の平均を求め、平均以上に買い物をしている顧客を抽出し、10件表示せよ。ただし、顧客IDが"Z"から始まるものは非会員を表すため、除外して計算すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .remove { customer_id.start_with?('Z') }
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .slice { amount >= amount.mean }
  .head(10)
```


### RA-036

レシート明細データ（df_receipt）と店舗データ（df_store）を内部結合し、レシート明細データの全項目と店舗データの店舗名（store_name）を10件表示せよ。

```{ruby}
#| tags: []
df_receipt.tdr
```

```{ruby}
#| tags: []
df_store.tdr
```

```{ruby}
#| tags: []
df_receipt.keys & df_store.keys
```

```{ruby}
#| tags: ["answer"]
df_receipt
  .inner_join(df_store.pick(:store_cd, :store_name))
  .tap { p _1.size }
  .head(10)
```


### RA-037

商品データ（df_product）とカテゴリデータ（df_category）を内部結合し、商品データの全項目とカテゴリデータのカテゴリ小区分名（category_small_name）を10件表示せよ。

```{ruby}
#| tags: []
df_product.tdr
```

```{ruby}
#| tags: []
df_category.tdr
```

```{ruby}
#| tags: []
picker = df_product.keys & df_category.keys
```

```{ruby}
#| tags: ["answer"]
df_product
  .inner_join(df_category.pick(picker << :category_small_name))
  .tap { p _1.size }
  .head(10)
```


### RA-038

顧客データ（df_customer）とレシート明細データ（df_receipt）から、顧客ごとの売上金額合計を求め、10件表示せよ。ただし、売上実績がない顧客については売上金額を0として表示させること。また、顧客は性別コード（gender_cd）が女性（1）であるものを対象とし、非会員（顧客IDが"Z"から始まるもの）は除外すること。

```{ruby}
#| tags: []
df_customer.tdra
```

```{ruby}
#| tags: []
df_receipt.tdr(elements: 4)
```

```{ruby}
#| tags: []
df_receipt.keys & df_store.keys
```

```{ruby}
#| tags: ["answer"]
customer_amount =
  df_receipt
    .remove { customer_id.start_with?('Z') }
    .group(:customer_id)
    .summarize { { sum_amount: sum(:amount) } }
```

```{ruby}
#| tags: ["answer"]
df_customer
  .slice { gender_cd == 1 }
  .pick(:customer_id)
  .outer_join(customer_amount)
  .assign(:sum_amount) { sum_amount.fill_nil(0) }
```


### RA-039

レシート明細データ（df_receipt）から、売上日数の多い顧客の上位20件を抽出したデータと、売上金額合計の多い顧客の上位20件を抽出したデータをそれぞれ作成し、さらにその2つを完全外部結合せよ。ただし、非会員（顧客IDが"Z"から始まるもの）は除外すること。

```{ruby}
#| tags: ["answer"]
member_group =
  df_receipt
    .remove { customer_id.start_with?('Z') }
    .group(:customer_id)

customer_days =
  member_group
    .count
    .sort('-count')
    .head(20)

customer_amount =
  member_group
    .summarize(:amount) { sum(:amount) }
    .sort('-amount')
    .head(20)

customer_days.full_join(customer_amount)
```


### RA-040

全ての店舗と全ての商品を組み合わせたデータを作成したい。店舗データ（df_store）と商品データ（df_product）を直積し、件数を計算せよ。

```{ruby}
#| tags: []
df_store.tdr
```

```{ruby}
#| tags: []
df_product.tdr
```

```{ruby}
#| tags: []
df_store.store_cd.uniq.size * df_product.product_cd.uniq.size
```

```{ruby}
#| tags: ["answer"]
# take a long time to process
df_store
  .assign(:key) { [0] * size }
  .full_join(df_product.assign(:key) {[0] * size })
  .size
```


### RA-041

レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、前回売上があった日からの売上金額増減を計算せよ。そして結果を10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:sales_ymd)
  .summarize(:amount) { sum(:amount) }
  .sort('sales_ymd')
  .assign(:diff) { amount.cast(:int32) - amount.shift }
  .head(10)
```


### RA-042

レシート明細データ（df_receipt）の売上金額（amount）を日付（sales_ymd）ごとに集計し、各日付のデータに対し、前回、前々回、3回前に売上があった日のデータを結合せよ。そして結果を10件表示せよ。

```{ruby}
#| tags: ["answer"]
shift_max = 3
df_receipt
  .group(:sales_ymd)
  .summarize(:amount) { sum(:amount) }
  .sort('sales_ymd')
  .then do |df|
    shift_max.times do |i|
      df =
        df.assign { ["sales_ymd_lag_#{i + 1}", sales_ymd.shift(i + 1)] }
          .assign { ["amount_lag_#{i + 1}", amount.shift(i + 1)] }    
    end
    df
  end
  .slice(lag_max...(lag_max + 10))
```


### RA-043

レシート明細データ（df_receipt）と顧客データ（df_customer）を結合し、性別コード（gender_cd）と年代（ageから計算）ごとに売上金額（amount）を合計した売上サマリデータを作成せよ。性別コードは0が男性、1が女性、9が不明を表すものとする。

ただし、項目構成は年代、女性の売上金額、男性の売上金額、性別不明の売上金額の4項目とすること（縦に年代、横に性別のクロス集計）。また、年代は10歳ごとの階級とすること。

```{ruby}
#| tags: ["answer"]
receipt =
  df_receipt
    .group(:customer_id)
    .summarize {{ amount: sum(:amount) }}
```

```{ruby}
#| tags: ["answer"]
wide =
  df_customer
    .pick(:customer_id, :gender, :age)
    .assign(:age_group) { (age / 10) * 10 }
    .inner_join(receipt)
    .group(:age_group, :gender) {{ amount: sum(:amount) }}
    .then { _1.concatenate(DataFrame.new(_1.schema, [[90, '男性', 0], [90, '不明', 0]])) }
    .sort('age_group')
    .to_wide(name: :gender, value: :amount)
```


### RA-044

043で作成した売上サマリデータ（df_sales_summary）は性別の売上を横持ちさせたものであった。このデータから性別を縦持ちさせ、年代、性別コード、売上金額の3項目に変換せよ。ただし、性別コードは男性を"00"、女性を"01"、不明を"99"とする。

```{ruby}
#| tags: []
wide
```

```{ruby}
#| tags: ["answer"]
wide
  .rename { keys[1..].zip(['01', '00', '99']) }
  .to_long(:age_group, name: :gender, value: :amount)
```


### RA-045

顧客データ（df_customer）の生年月日（birth_day）は日付型でデータを保有している。これをYYYYMMDD形式の文字列に変換し、顧客ID（customer_id）とともに10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .pick(:customer_id, :birth_day)
  .assign(:birth_day) { birth_day.map { _1.strftime('%Y%m%d')} }
  .head(10)
```


### RA-046

顧客データ（df_customer）の申し込み日（application_date）はYYYYMMDD形式の文字列型でデータを保有している。これを日付型に変換し、顧客ID（customer_id）とともに10件表示せよ。

```{ruby}
#| tags: ["answer"]
DataFrame.new(
  application_date: df_customer.application_date.map { Date.parse(_1.to_s) },
  customer_id: df_customer.customer_id
)
  .head(10)
```


### RA-047

レシート明細データ（df_receipt）の売上日（sales_ymd）はYYYYMMDD形式の数値型でデータを保有している。これを日付型に変換し、レシート番号（receipt_no）、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。

```{ruby}
#| tags: ["answer"]
DataFrame.new(
  sales_date: df_receipt.sales_ymd.map { Date.parse(_1.to_s) },
  receipt_no: df_receipt.receipt_no,
  receipt_sub_no: df_receipt.receipt_sub_no
)
```


### RA-048

レシート明細データ（df_receipt）の売上エポック秒（sales_epoch）は数値型のUNIX秒でデータを保有している。これを日付型に変換し、レシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(%i[receipt_no receipt_sub_no])
  .assign(:sales_date) { df_receipt.sales_epoch.map { Time.at(_1) } }
  .head(10)
```

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(%i[receipt_no receipt_sub_no])
  .assign(:sales_date) { Vector.new(Arrow::Date64Array.new(df_receipt.sales_epoch * 1000)) }
  .head(10)
```


### RA-049

レシート明細データ（df_receipt）の売上エポック秒（sales_epoch）を日付型に変換し、「年」だけ取り出してレシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(%i[receipt_no receipt_sub_no])
  .assign(:sales_year) { df_receipt.sales_epoch.map { Time.at(_1).strftime('%Y') } }
  .head(10)
```


### RA-050

レシート明細データ（df_receipt）の売上エポック秒（sales_epoch）を日付型に変換し、「月」だけ取り出してレシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。なお、「月」は0埋め2桁で取り出すこと。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(%i[receipt_no receipt_sub_no])
  .assign(:sales_month) { df_receipt.sales_epoch.map { Time.at(_1).strftime('%m') } }
  .head(10)
```


### RA-051

レシート明細データ（df_receipt）の売上エポック秒を日付型に変換し、「日」だけ取り出してレシート番号(receipt_no)、レシートサブ番号（receipt_sub_no）とともに10件表示せよ。なお、「日」は0埋め2桁で取り出すこと。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(%i[receipt_no receipt_sub_no])
  .assign(:sales_day) { df_receipt.sales_epoch.map { Time.at(_1).strftime('%d') } }
  .head(10)
```


### RA-052

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計の上、売上金額合計に対して2,000円以下を0、2,000円より大きい金額を1に二値化し、顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .remove { customer_id.start_with?('Z') }
  .group(:customer_id)
  .summarize {{ amount: sum(:amount) }}
  .assign(:sales_bit) { (amount > 2000).if_else(1, 0) }
  .head(10)
```


### RA-053

顧客データ（df_customer）の郵便番号（postal_cd）に対し、東京（先頭3桁が100〜209のもの）を1、それ以外のものを0に二値化せよ。さらにレシート明細データ（df_receipt）と結合し、全期間において売上実績のある顧客数を、作成した二値ごとにカウントせよ。

```{ruby}
#| tags: ["answer"]
customer =
  df_customer
    .pick(:customer_id, :postal_cd)
    .assign(:is_tokyo) do
      postal3 = postal_cd.map { _1.split('-')[0].to_i }
      is_tokyo = (postal3 >= 100) & (postal3 <= 209)
      is_tokyo.if_else(1, 0)
    end
```

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:customer_id, :amount)
  .join(customer)
  .group(:is_tokyo)
  .count
```


### RA-054

顧客データ（df_customer）の住所（address）は、埼玉県、千葉県、東京都、神奈川県のいずれかとなっている。都道府県毎にコード値を作成し、顧客ID、住所とともに10件表示せよ。値は埼玉県を11、千葉県を12、東京都を13、神奈川県を14とすること。

```{ruby}
#| tags: ["answer"]
prefs = {'埼玉県' => 11, '千葉県' => 12, '東京都' => 13, '神奈川県' => 14}
reg = Regexp.new(prefs.keys.join('|'))

df_customer
  .pick(:customer_id, :address)
  .assign(:pref_cd) do
    address.map do |addr|
      m = reg.match(addr)
      prefs[m[0]]
    end
  end
  .head(10)
```


### RA-055

レシート明細（df_receipt）データの売上金額（amount）を顧客ID（customer_id）ごとに合計し、その合計金額の四分位点を求めよ。その上で、顧客ごとの売上金額合計に対して以下の基準でカテゴリ値を作成し、顧客ID、売上金額合計とともに10件表示せよ。カテゴリ値は順に1〜4とする。

- 最小値以上第1四分位未満    ・・・ 1を付与
- 第1四分位以上第2四分位未満 ・・・ 2を付与
- 第2四分位以上第3四分位未満 ・・・ 3を付与
- 第3四分位以上            ・・・ 4を付与

```{ruby}
#| tags: ["answer"]
df_customer_amount =
  df_receipt
    .group(:customer_id)
    .summarize(:amount) { sum(:amount) }
```

```{ruby}
#| tags: []
df_customer_amount.amount.quantiles
```

```{ruby}
#| tags: ["answer"]
quantiled =
  df_customer_amount
    .assign(:amount_class) do
      Vector.new([1] * size)
        .replace(amount >= amount.quantile(0.25), 2)
        .replace(amount >= amount.quantile(0.5), 3)
        .replace(amount >= amount.quantile(0.75), 4)
    end
```

```{ruby}
#| tags: ["answer"]
quantiled.head(10)
```

```{ruby}
#| tags: []
quantiled
  .group(:amount_class)
  .count
  .sort('amount_class')
```


### RA-056

顧客データ（df_customer）の年齢（age）をもとに10歳刻みで年代を算出し、顧客ID（customer_id）、生年月日（birth_day）とともに10件表示せよ。ただし、60歳以上は全て60歳代とすること。年代を表すカテゴリ名は任意とする。

```{ruby}
#| tags: []
df_customer
  .tdr(elements: 4)
```

```{ruby}
#| tags: ["answer"]
df_customer
  .pick(:customer_id, :birth_day, :age)
  .assign(:age_class) do
    age_class = (age / 10) * 10
    age_class.replace(age_class > 60, 60)
  end => df_customer_age
df_customer_age.tdr(elements: 4)
```

```{ruby}
#| tags: ["answer"]
df_customer_age.head(10)
```

```{ruby}
#| tags: []
df_customer_age
  .group(:age_class)
  .count
  .sort('age_class')
```


### RA-057

056の抽出結果と性別コード（gender_cd）により、新たに性別×年代の組み合わせを表すカテゴリデータを作成し、10件表示せよ。組み合わせを表すカテゴリの値は任意とする。

```{ruby}
#| tags: ["answer"]
df_customer_age
  .assign(:gender_age) do
    df_customer.gender_cd.cast(:string).merge(age_class.cast(:string), sep: ',')
  end
  .tap { p _1.group(:gender_age).count.sort('gender_age') }
  .head(10)
```


### RA-058

顧客データ（df_customer）の性別コード（gender_cd）をダミー変数化し、顧客ID（customer_id）とともに10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .assign do
    codes = gender_cd.unique.to_a
    codes.map do |code|
      vector = (gender_cd == code).if_else(1, 0)
      ["gender_cd_#{code}", vector]
    end
  end
  .pick(:customer_id, :gender_cd, -1, -3, -2)
  .tap { _1.tdr(elements: 4) }
  .head(10)
```


### RA-059

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を平均0、標準偏差1に標準化して顧客ID、売上金額合計とともに10件表示せよ。標準化に使用する標準偏差は、分散の平方根、もしくは不偏分散の平方根のどちらでも良いものとする。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .remove { customer_id.start_with?('Z') }
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .assign(:norm_amount) { (amount - amount.mean).cast(:double) / amount.sd }
  .tap { |df| p [:mean, :sd].map { |method| df.norm_amount.send(method) } }
  .head(10)
```


### RA-060

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を最小値0、最大値1に正規化して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .remove { customer_id.start_with?('Z') }
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .assign(:norm_amount) { (amount - amount.min).cast(:float) / (amount.max - amount.min) }
  .tap { |df| p [:min, :max].map { |method| df.norm_amount.send(method) } }
  .head(10)
```


### RA-061

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を常用対数化（底10）して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .remove { customer_id.start_with?('Z') }
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .assign(:log_amount) { amount.log10 }
  .head(10)
```


### RA-062

レシート明細データ（df_receipt）の売上金額（amount）を顧客ID（customer_id）ごとに合計し、売上金額合計を自然対数化（底e）して顧客ID、売上金額合計とともに10件表示せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .remove { customer_id.start_with?('Z') }
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .assign(:ln_amount) { amount.ln }
  .head(10)
```


### RA-063

商品データ（df_product）の単価（unit_price）と原価（unit_cost）から各商品の利益額を算出し、結果を10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_product
  .pick(:product_cd, :unit_price, :unit_cost)
  .assign(:unit_profit) { unit_price - unit_cost }
  .head(10)
```


### RA-064

商品データ（df_product）の単価（unit_price）と原価（unit_cost）から、各商品の利益率の全体平均を算出せよ。ただし、単価と原価には欠損が生じていることに注意せよ。

```{ruby}
#| tags: []
df_product.tdr
```

```{ruby}
#| tags: []
df_product
  .slice { unit_price.is_nil }
```

```{ruby}
#| tags: ["answer"]
df =
  df_product
    .pick(:product_cd, :unit_price, :unit_cost)
    .assign(:unit_profit_ratio) { (unit_price.cast(:double) - unit_cost)/ unit_price }
```

```{ruby}
#| tags: ["answer"]
df.unit_profit_ratio.mean
```


### RA-065

商品データ（df_product）の各商品について、利益率が30%となる新たな単価を求めよ。ただし、1円未満は切り捨てること。そして結果を10件表示させ、利益率がおよそ30％付近であることを確認せよ。ただし、単価（unit_price）と原価（unit_cost）には欠損が生じていることに注意せよ。

```{ruby}
#| tags: ["answer"]
result =
  df_product
    .pick(:product_cd, :unit_price, :unit_cost)
    .assign(:new_unit_price) { (unit_cost / 0.7).trunc }
    .assign(:ratio) { (new_unit_price - unit_cost.cast(:double)) / new_unit_price }
```

```{ruby}
#| tags: ["answer"]
result.slice { ratio == ratio.max }
```

```{ruby}
#| tags: []
result.tdr(elements: 3)
```


### RA-066

商品データ（df_product）の各商品について、利益率が30%となる新たな単価を求めよ。今回は、1円未満を丸めること（四捨五入または偶数への丸めで良い）。そして結果を10件表示させ、利益率がおよそ30％付近であることを確認せよ。ただし、単価（unit_price）と原価（unit_cost）には欠損が生じていることに注意せよ。

```{ruby}
#| tags: ["answer"]
df_product
  .pick(:product_cd, :unit_price, :unit_cost)
  .assign(:new_unit_price) { (unit_cost / 0.7).round }
  .head(10)
  .assign(:ratio) { (new_unit_price - unit_cost.cast(:double)) / new_unit_price }
```


### RA-067

商品データ（df_product）の各商品について、利益率が30%となる新たな単価を求めよ。今回は、1円未満を切り上げること。そして結果を10件表示させ、利益率がおよそ30％付近であることを確認せよ。ただし、単価（unit_price）と原価（unit_cost）には欠損が生じていることに注意せよ。

```{ruby}
#| tags: ["answer"]
df_product
  .pick(:product_cd, :unit_price, :unit_cost)
  .assign(:new_unit_price) { (unit_cost / 0.7).ceil }
  .head(10)
  .assign(:ratio) { (new_unit_price - unit_cost.cast(:double)) / new_unit_price }
```


### RA-068

商品データ（df_product）の各商品について、消費税率10％の税込み金額を求めよ。1円未満の端数は切り捨てとし、結果を10件表示せよ。ただし、単価（unit_price）には欠損が生じていることに注意せよ。

```{ruby}
#| tags: ["answer"]
df_product
  .pick(:product_cd, :unit_price, :unit_cost)
  .assign(:unit_price_with_tax) { (unit_cost * 1.1).trunc }
  .head(10)
```


### RA-069

レシート明細データ（df_receipt）と商品データ（df_product）を結合し、顧客毎に全商品の売上金額合計と、カテゴリ大区分コード（category_major_cd）が"07"（瓶詰缶詰）の売上金額合計を計算の上、両者の比率を求めよ。抽出対象はカテゴリ大区分コード"07"（瓶詰缶詰）の売上実績がある顧客のみとし、結果を10件表示せよ。

```{ruby}
#| tags: []
df_receipt.keys & df_product.keys
```

```{ruby}
#| tags: ["answer"]
df_receipt
  .join(df_product)
  .pick(:customer_id, :amount, :category_major_cd) => df

df.group(:customer_id)
  .summarize(:amount) { sum(:amount) } => df_all

df.slice { category_major_cd == 7 }
  .group(:customer_id)
  .summarize(:amount_07) { sum(:amount) } => df_07

df_all
  .right_join(df_07)
  .assign(:ratio) { amount_07.cast(:double) / amount }
  .head(10)
```


### RA-070

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、顧客データ（df_customer）の会員申込日（application_date）からの経過日数を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:customer_id, :sales_ymd)
  .join(df_customer.pick(:customer_id, :application_date))
  .assign(:sales_date, :application_date, :period_days) do
    sales_ymd.zip(application_date).map do |s, a|
      sales = Date.parse(s.to_s)
      appli = Date.parse(a.to_s)
      period = sales - appli
      [sales, appli, period.to_i]
    end
    .transpose
  end
  .drop(:sales_ymd)
  .head(10)
```


### RA-071

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、顧客データ（df_customer）の会員申込日（application_date）からの経過月数を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。1ヶ月未満は切り捨てること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:customer_id, :sales_ymd)
  .join(df_customer.pick(:customer_id, :application_date))
  .assign(:sales_date, :application_date, :period_month) do
    sales_ymd.zip(application_date).map do |s, a|
      sales = Date.parse(s.to_s)
      appli = Date.parse(a.to_s)
      period = sales.year * 12 + sales.month - appli.year * 12 - appli.month
      [sales, appli, period.to_i]
    end
    .transpose
  end
  .drop(:sales_ymd)
  .head(10)
```


### RA-072

レシート明細データ（df_receipt）の売上日（df_customer）に対し、顧客データ（df_customer）の会員申込日（application_date）からの経過年数を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。1年未満は切り捨てること。

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:customer_id, :sales_ymd)
  .join(df_customer.pick(:customer_id, :application_date))
  .assign(:sales_date, :application_date, :period_year) do
    sales_ymd.zip(application_date).map do |s, a|
      sales = Date.parse(s.to_s)
      appli = Date.parse(a.to_s)
      period = sales.year - appli.year
      [sales, appli, period.to_i]
    end
    .transpose
  end
  .drop(:sales_ymd)
  .head(10)
```


### RA-073

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、顧客データ（df_customer）の会員申込日（application_date）からのエポック秒による経過時間を計算し、顧客ID（customer_id）、売上日、会員申込日とともに10件表示せよ（なお、sales_ymdは数値、application_dateは文字列でデータを保持している点に注意）。なお、時間情報は保有していないため各日付は0時0分0秒を表すものとする。

```{ruby}
#| tags: []
df_customer.application_date 
```

```{ruby}
#| tags: ["answer"]
df_receipt
  .pick(:customer_id, :sales_ymd)
  .join(df_customer.pick(:customer_id, :application_date))
  .assign(:sales_date, :application_date, :period_month) do
    sales_ymd.zip(application_date).map do |s, a|
      sales = Date.parse(s.to_s)
      appli = Date.parse(a.to_s)
      period = sales.year * 12 + sales.month - appli.year * 12 - appli.month
      [sales, appli, period.to_i]
    end
    .transpose
  end
  .drop(:sales_ymd)
  .head(10)
```


### RA-074

レシート明細データ（df_receipt）の売上日（sales_ymd）に対し、当該週の月曜日からの経過日数を計算し、売上日、直前の月曜日付とともに10件表示せよ（sales_ymdは数値でデータを保持している点に注意）。

```{ruby}
d = Date.strptime('20230529', '%Y%m%d')
(d - (d.wday == 0 ? 6 :d.wday - 1))
```

```{ruby}
#| tags: ["answer"]
df_monday =
  DataFrame.new(
    sales_date: df_receipt.sales_ymd.map { Date.strptime(_1.to_s, '%Y%m%d') }
  )
    .assign(wday: sales_date.map { _1.wday })
    .assign(last_monday: sales_date.map { _1 - (_1.wday == 0 ? 6 : _1.wday - 1) })
```


### RA-075

顧客データ（df_customer）からランダムに1%のデータを抽出し、先頭から10件表示せよ。

```{ruby}
#| tags: []
df_customer.size * 0.01
```

```{ruby}
#| tags: ["answer"]
df_customer
  .slice { indices.sample(0.01) }
  .head(10)
```


### RA-076

顧客データ（df_customer）から性別コード（gender_cd）の割合に基づきランダムに10%のデータを層化抽出し、性別コードごとに件数を集計せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .group(:gender_cd)
  .count
  .assign(:sampling_count) { (count * 0.1).cast_to(:int32) }
```

別の方法

```{ruby}
#| tags: ["answer"]
df_customer
  .sub_group(:gender_cd)
  .map { |df| df.slice { indices.sample(0.1) } }
  .aggregate(:gender_cd, :sampling_count) { [gender_cd.one, size] }
```


### RA-077

レシート明細データ（df_receipt）の売上金額を顧客単位に合計し、合計した売上金額の外れ値を抽出せよ。なお、外れ値は売上金額合計を対数化したうえで平均と標準偏差を計算し、その平均から3σを超えて離れたものとする（自然対数と常用対数のどちらでも可）。結果は10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .assign(:log_amount) { amount.log10 }
  .tap { p _1.size }
  .remove do
    mean = log_amount.mean
    sd = log_amount.sd
    (log_amount < (mean - sd * 3)) | (log_amount > (mean + sd * 3))
  end
  .tap { p _1.size }
  .head(10)
```


### RA-078

レシート明細データ（df_receipt）の売上金額（amount）を顧客単位に合計し、合計した売上金額の外れ値を抽出せよ。ただし、顧客IDが"Z"から始まるのものは非会員を表すため、除外して計算すること。なお、ここでは外れ値を第1四分位と第3四分位の差であるIQRを用いて、「第1四分位数-1.5×IQR」を下回るもの、または「第3四分位数+1.5×IQR」を超えるものとする。結果は10件表示せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .remove { customer_id.map { _1.start_with?('Z') } }
  .slice do
    q25 = amount.quantile(0.25)
    q75 = amount.quantile(0.75)
    iqr = q75 - q25
    (amount < (q25 - 1.5 * iqr)) | (amount > (q75 + 1.5 * iqr))
  end
  .tap { p _1.size }
  .head(10)
```


### RA-079

商品データ（df_product）の各項目に対し、欠損数を確認せよ。

```{ruby}
#| tags: []
df_product.tdr
```

```{ruby}
#| tags: ["answer"]
DataFrame.new(
  key: df_product.keys,
  missing_count: df_product.keys.map { |key| df_product.v(key).is_nil.sum },
)
```


### RA-080

商品データ（df_product）のいずれかの項目に欠損が発生しているレコードを全て削除した新たな商品データを作成せよ。なお、削除前後の件数を表示させ、079で確認した件数だけ減少していることも確認すること。

```{ruby}
#| tags: []
df_product.tdr
```

```{ruby}
#| tags: ["answer"]
df_product.remove_nil.tdr
```


### RA-081

単価（unit_price）と原価（unit_cost）の欠損値について、それぞれの平均値で補完した新たな商品データを作成せよ。なお、平均値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。

```{ruby}
#| tags: ["answer"]
df_product
  .assign(:unit_price, :unit_cost) do
    [ unit_price.fill_nil(unit_price.mean).round,
      unit_cost.fill_nil(unit_cost.mean).round ]
  end => filled
filled.tdr
```

```{ruby}
#| tags: ["answer"]
indices = df_product.indices.filter(df_product.unit_price.is_nil)
df_product.slice(indices)
```

```{ruby}
#| tags: ["answer"]
filled.slice(indices)
```


### RA-082

単価（unit_price）と原価（unit_cost）の欠損値について、それぞれの中央値で補完した新たな商品データを作成せよ。なお、中央値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。

```{ruby}
#| tags: ["answer"]

```


### RA-083

単価（unit_price）と原価（unit_cost）の欠損値について、各商品のカテゴリ小区分コード（category_small_cd）ごとに算出した中央値で補完した新たな商品データを作成せよ。なお、中央値については1円未満を丸めること（四捨五入または偶数への丸めで良い）。補完実施後、各項目について欠損が生じていないことも確認すること。

```{ruby}
#| tags: ["answer"]

```


### RA-084

顧客データ（df_customer）の全顧客に対して全期間の売上金額に占める2019年売上金額の割合を計算し、新たなデータを作成せよ。ただし、売上実績がない場合は0として扱うこと。そして計算した割合が0超のものを抽出し、結果を10件表示せよ。また、作成したデータに欠損が存在しないことを確認せよ。

```{ruby}
#| tags: ["answer"]

```


### RA-085

顧客データ（df_customer）の全顧客に対し、郵便番号（postal_cd）を用いてジオコードデータ（df_geocode）を紐付け、新たな顧客データを作成せよ。ただし、1つの郵便番号（postal_cd）に複数の経度（longitude）、緯度（latitude）情報が紐づく場合は、経度（longitude）、緯度（latitude）の平均値を算出して使用すること。また、作成結果を確認するために結果を10件表示せよ。

```{ruby}
#| tags: []
df_geocode.group(:postal_cd).count.slice { count > 1 }
```

```{ruby}
#| tags: ["answer"]
df_geocode
  .group(:postal_cd)
  .summarize(:longitude, :latitude) { [mean(:longitude), mean(:latitude)] } => geocode
geocode
```

```{ruby}
#| tags: ["answer"]
customer = df_customer.join(geocode)
customer.head(10)
```


### RA-086

085で作成した緯度経度つき顧客データに対し、会員申込店舗コード（application_store_cd）をキーに店舗データ（df_store）と結合せよ。そして申込み店舗の緯度（latitude）・経度情報（longitude)と顧客住所（address）の緯度・経度を用いて申込み店舗と顧客住所の距離（単位：km）を求め、顧客ID（customer_id）、顧客住所（address）、店舗住所（address）とともに表示せよ。計算式は以下の簡易式で良いものとするが、その他精度の高い方式を利用したライブラリを利用してもかまわない。結果は10件表示せよ。

$$
\mbox{緯度（ラジアン）}：\phi \\
\mbox{経度（ラジアン）}：\lambda \\
\mbox{距離}L = 6371 * \arccos(\sin \phi_1 * \sin \phi_2
+ \cos \phi_1 * \cos \phi_2 * \cos(\lambda_1 − \lambda_2))
$$

```{ruby}
#| tags: []
df_customer.keys
```

```{ruby}
#| tags: []
df_store.keys
```

```{ruby}
#| tags: ["answer"]
joined = customer.join(df_store, join_keys = {left: :application_store_cd, right: :store_cd})
joined.tdra(elements: 2)
```

```{ruby}
#| tags: ["answer"]
joined
  .assign(:distance) do
    long1 = longitude * Math::PI / 180
    long2 = v(:"longitude.1") * Math::PI / 180
    lat1 = latitude * Math::PI / 180
    lat2 = v(:"latitude.1")  * Math::PI / 180
    (lat1.sin * lat2.sin + lat1.cos * lat2.cos * (long1 - long2).cos).acos * 6371
  end
  .pick(:customer_id, :address, :"address.1", :distance)
  .rename(:address => :customer_address, :"address.1" => :store_address)
```


### RA-087

顧客データ（df_customer）では、異なる店舗での申込みなどにより同一顧客が複数登録されている。名前（customer_name）と郵便番号（postal_cd）が同じ顧客は同一顧客とみなして1顧客1レコードとなるように名寄せした名寄顧客データを作成し、顧客データの件数、名寄顧客データの件数、重複数を算出せよ。ただし、同一顧客に対しては売上金額合計が最も高いものを残し、売上金額合計が同一もしくは売上実績がない顧客については顧客ID（customer_id）の番号が小さいものを残すこととする。

```{ruby}
#| tags: ["answer"]
df_customer
  .assign(:customer_name_postal_cd) { customer_name.merge(postal_cd, sep: ',') }
  .group(:customer_name_postal_cd)
  .count => df_aggregated
df_aggregated
```

```{ruby}
#| tags: ["answer"]
df_aggregated
  .slice { count > 1 } => df_duplicated
df_duplicated
```

```{ruby}
#| tags: ["answer"]
puts "顧客データ件数: #{df_customer.size}"
puts "名寄せ顧客データ件数: #{df_aggregated.size}"
puts "重複数: #{df_duplicated.size}"
```


### RA-088

087で作成したデータを元に、顧客データに統合名寄IDを付与したデータを作成せよ。ただし、統合名寄IDは以下の仕様で付与するものとする。

- 重複していない顧客：顧客ID（customer_id）を設定
- 重複している顧客：前設問で抽出したレコードの顧客IDを設定

顧客IDのユニーク件数と、統合名寄IDのユニーク件数の差も確認すること。

```{ruby}
#| tags: ["answer"]

```


### RA-089

売上実績がある顧客を、予測モデル構築のため学習用データとテスト用データに分割したい。それぞれ8:2の割合でランダムにデータを分割せよ。

```{ruby}
#| tags: ["answer"]
sales_customer =
  DataFrame.new(customer_id: df_customer.customer_id.uniq)
    .assign_left(:index) { _1.indices }
```

```{ruby}
#| tags: ["answer"]
train_indeces = sales_customer[:index].sample(0.8)
```

```{ruby}
#| tags: ["answer"]
train = sales_customer.slice(train_indeces)
```

```{ruby}
#| tags: ["answer"]
test = sales_customer.remove(train_indeces)
```

```{ruby}
#| tags: ["answer"]
train.union(test).tdr
```



### RA-090

レシート明細データ（df_receipt）は2017年1月1日〜2019年10月31日までのデータを有している。売上金額（amount）を月次で集計し、学習用に12ヶ月、テスト用に6ヶ月の時系列モデル構築用データを3セット作成せよ。

```{ruby}
#| tags: []
df_receipt.sales_ymd.min_max
```

```{ruby}
#| tags: ["answer"]
df_receipt
  .assign(:sales_ym) { sales_ymd.map { _1.to_s[..5] } }
  .group(:sales_ym)
  .summarize(:amount) { sum(:amount) }
  .sort('sales_ym') => df_all
df_all
```

```{ruby}
#| tags: ["answer"]
train_size = 12
test_size = 6
n_split = 3
step = (df_all.size - (train_size + test_size)) / (n_split - 1) # => 8 (Pythonの TimeSeriesSplitは最新を使う)
step = 6 # SQLとRに合わせる

df_all
  .sub_by_window(size: train_size + test_size, step: step)
  .each.map do |df|
    df.build_subframes { indices.partition { |i| i < train_size } }.to_a
  end
```


### RA-091

顧客データ（df_customer）の各顧客に対し、売上実績がある顧客数と売上実績がない顧客数が1:1となるようにアンダーサンプリングで抽出せよ。

```{ruby}
#| tags: ["answer"]
df_receipt
  .group(:customer_id)
  .summarize(:amount) { sum(:amount) }
  .right_join(df_customer, group_keys = :customer_id)
  .assign(:is_sales) { amount.is_nil.if_else(0, 1) } => df
df.group(:is_sales)
```

```{ruby}
#| tags: ["answer"]
df.sub_group(:is_sales)
  .map do |df|
    if df.is_sales.first == 1
      df
    else
      df.slice { indices.sample(8306) }
    end
  end
  .to_a
```


### RA-092

顧客データ（df_customer）の性別について、第三正規形へと正規化せよ。

```{ruby}
#| tags: ["answer"]
df_customer
  .drop(6..)
  .assign(:gender) do
    gender
      .replace(gender == '女性', 'female')
      .replace(gender == '男性', 'male')
      .replace(gender == '不明', 'unknown')
  end => df_customer
```

```{ruby}
#| tags: []
df_customer
  .tdra(elements: 2)
```

```{ruby}
#| tags: ["answer"]
df_gender_std =
  df_customer
    .group(:gender_cd, :gender)
    .grouped_frame
```

```{ruby}
#| tags: ["answer"]
df_customer_std =
  df_customer
    .drop(:gender)
    .tdra(elements: 2)
```


### RA-093

商品データ（df_product）では各カテゴリのコード値だけを保有し、カテゴリ名は保有していない。カテゴリデータ（df_category）と組み合わせて非正規化し、カテゴリ名を保有した新たな商品データを作成せよ。

```{ruby}
#| tags: []
df_product.tdr
```

```{ruby}
#| tags: []
df_category.tdr
```

```{ruby}
#| tags: ["answer"]
df_product_full =
  df_product.join(df_category.pick([:category_major_cd,
                                    :category_major_name,
                                    :category_medium_name,
                                    :category_small_name]))
```


### RA-094

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|有り|UTF-8|
> 
> ファイル出力先のパスは以下のようにすること
> 
> |出力先|
> |:--:|
> |./data|

```{ruby}
#| tags: ["answer"]
df_product_full.save('./work/RedAmber_df_product_full_UTF-8_header.csv')
```


### RA-095

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|有り|CP932|
> 
> ファイル出力先のパスは以下のようにすること。
> 
> |出力先|
> |:--:|
> |./data|

```{ruby}
#| tags: ["answer"]
df_product_full.save('./work/RedAmber_df_product_full_CP932_header.csv', encoding: 'CP932:UTF-8')
```


### RA-096

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|無し|UTF-8|
> 
> ファイル出力先のパスは以下のようにすること。
> 
> |出力先|
> |:--:|
> |./data|

```{ruby}
#| tags: ["answer"]
df_product_full.save('./work/RedAmber_df_product_full_UTF-8_noheader.csv', headers: false)
```


### RA-097

094で作成した以下形式のファイルを読み込み、データを3件を表示させて正しく取り込まれていることを確認せよ。
> 
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|有り|UTF-8|

```{ruby}
#| tags: ["answer"]
df_product_full =
  DataFrame.load('./work/RedAmber_df_product_full_UTF-8_header.csv')
```


### RA-098

096で作成した以下形式のファイルを読み込み、データを3件を表示させて正しく取り込まれていることを確認せよ。
> 
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |CSV（カンマ区切り）|ヘッダ無し|UTF-8|

```{ruby}
#| tags: ["answer"]
loaded =
  DataFrame.load('./work/RedAmber_df_product_full_UTF-8_noheader.csv', headers: false)
renamer =
  loaded.keys.zip(
    [
      :product_cd,
      :category_major_cd,
      :category_medium_cd,
      :category_small_cd,
      :unit_price,
      :unit_cost,
      :category_major_name,
      :category_medium_name,
      :category_small_name
    ]
  )

df_product_full = loaded.rename(renamer)
```


### RA-099

093で作成したカテゴリ名付き商品データを以下の仕様でファイル出力せよ。
>
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |TSV（タブ区切り）|有り|UTF-8|
> 
> ファイル出力先のパスは以下のようにすること
> 
> |出力先|
> |:--:|
> |./data|

```{ruby}
#| tags: ["answer"]
df_product_full.save('./work/RedAmber_df_product_full_UTF-8_header.tsv')
```


### RA-100

099で作成した以下形式のファイルを読み込み、データを3件を表示させて正しく取り込まれていることを確認せよ。
> 
> |ファイル形式|ヘッダ有無|文字エンコーディング|
> |:--:|:--:|:--:|
> |TSV（タブ区切り）|有り|UTF-8|

```{ruby}
#| tags: []["answer"]
df_product_full =
  DataFrame.load('./work/RedAmber_df_product_full_UTF-8_header.tsv')
```


## これで100本終わりです。おつかれさまでした！
